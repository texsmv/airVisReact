{% extends 'api/layout.html' %} 
{% load unicorn %} 
{% unicorn_scripts %} 
{%block content %} 
{% load static %}

<div  class="container" style="position: relative">
  {% if not request.user.is_authenticated %}
  <h1>Welcome to FocusPlus</h1>
  <p>
    FocusPlus is a web application that allows you to track your time and focus
    on your tasks.
  </p>
  {% else %}
  <div class="container-fluid">
    <div class="col-md-10">
      <div style="width: 5cm;" class="col-md-1">
        <label for="customRange1" class="form-label">Shape ratio</label>
        <p> 1 to only use shape descriptor 0 to use only the mean magnitude </p>
        <input type="range" class="form-range" id="range1" onchange='showRatio(this.value)' min="0" max="1" step="0.01" value="0.5">
      </div>
      <div class="row">
        <div class="col-md-2">
          {% for pollutant in pollutants %}
            <div class="row">
              <div style="width: 5cm;" class="col-md-1">
                <label for="customRange1" class="form-label">{{ pollutant.name }}</label>
                <input type="range" class="form-range" id="range1" onchange='showVal(this.value, {{pollutant.id}})' min="0" max="1" step="0.01" value="1">
              </div>
            </div>
          {% endfor %}
        </div>
        <div class="col-md-6">
          <div id="mainProj" style="width: 20cm;" class="col-md-1">
            <h3>Main projection</h3>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-md-4">
          {% for pollutant in pollutants %}
            <button type="button" onclick="selectPollutant({{pollutant.id}})" class="btn btn-secondary">{{pollutant.name}}</button>
          {% endfor %}
          <div id="pollutantProj" style="width: 9cm;" class="col-md-1">
            <h3 id='selectedPollutantTitle'>  Projection for: {{selected_pollutant.name}}</h3>
          </div>
        </div>
        <div class="col-md-4">
          <div id="timeSeries" style="width: 9cm;" class="col-md-1">
            <br>
            <br>
            <br>
            <h3>Time series</h3>
          </div>
        </div>
        <div class="col-md-4">
            
        </div>
      </div>
    </div>

    <div class="col-md-1">
      <div class="row">
        <h3> Stations </h3>
      </div>

      {% for station in stations %}
        <div class="row">
          <button id = 'station_{{station.id}}' type="button" onclick="selectStation({{station.id}})" class="btn btn-secondary">{{station.name}}</button>
        </div>
      {% endfor %}

    </div>
    <div class="col-md-1">
      <div class="row">
        <h3> Years </h3>
      </div>
  
      {% for year in years %}
        <div class="row">
          <button id = 'year_{{year}}' type="button" onclick="selectYear({{year}})" class="btn btn-secondary">{{year}}</button>
        </div>
      {% endfor %}
    </div>
  </div>

    
  
  <script>
    var points = []
    var pollutant_coordenates = []
    var windows = []
    var norm_windows = []
    var ratio = 0.5

    var all_pollutants = []
    var selected_pollutant = {}

    var lassoMain = 0
    var lassoPollutant = 0

    selected_pollutant['name'] = '{{selected_pollutant.name}}'
    selected_pollutant['id'] = '{{selected_pollutant.name}}'

    {% for pollutant in pollutants %}
      var data = {}
      data['name'] = '{{pollutant.name}}'
      data['id'] = '{{pollutant.id}}'
      data['val'] = 1
      all_pollutants.push(data)
    {% endfor %}

    station_colors = {}
    {% for station in stations %}
      station_colors['{{station.id}}'] = '#' + Math.floor(Math.random()*16777215).toString(16)
      document.getElementById('station_{{station.id}}').style.background=station_colors['{{station.id}}'];
    {% endfor %}

    years_colors = {}
    {% for year in years %}
      years_colors['{{year}}'] = '#' + Math.floor(Math.random()*16777215).toString(16)
      document.getElementById('year_{{year}}').style.background=years_colors['{{year}}'];
    {% endfor %}


    function updateMainCircles(){

      // Update main view
      var xMain = d3.scaleLinear()
      .domain([-1, 1])
      .range([ 0, mainWidth ]);
      
      var yMain = d3.scaleLinear()
        .domain([-1, 1])
        .range([ mainHeight, 0]);
  
      circlesMain = mainProjectionSvg.selectAll("circle");
      circlesMain.remove();
  
      var circlesMain = mainProjectionSvg
      .append("g")
      .selectAll(".dot")
      .data(points)
      .enter()
      .append("circle")
      .style('fill', function(d,i) {
          return d.color;
      })
      .attr("cx", (d) => xMain(d.m_pos[0]))
      .attr("cy", (d) => yMain(d.m_pos[1]))
      .attr("r", function(d,i) {
        return d.r;
      });

      

      
      circlesMain = mainProjectionSvg.selectAll("circle");
  
      lassoMain.items(circlesMain)
    }

    function updatePollutantCircles(){

      // Update main view
      var xPoll = d3.scaleLinear()
        .domain([-1, 1])
        .range([ 0, spanelWidth ]);
      
      var yPoll = d3.scaleLinear()
        .domain([-1, 1])
        .range([ spanelHeight, 0]);

      circlesPoll = pollutantProjectionSvg.selectAll("circle");
      circlesPoll.remove();

      var circlesPoll = pollutantProjectionSvg
      .append("g")
      .selectAll(".dot")
      .data(points)
      .enter()
      .append("circle")
      .style('fill', function(d,i) {
          return d.color;
      })
      .attr("cx", (d) => xPoll(d.p_pos[0]))
      .attr("cy", (d) => yPoll(d.p_pos[1]))
      .attr("r", radiusUnselected);
      
      circlesPoll = pollutantProjectionSvg.selectAll("circle");
      lassoPollutant.items(circlesPoll);
    }

    function updateSeries(){

      path = timeSeriesSvg.selectAll("path");
      path.remove();
      
      timeSeriesSvg.selectAll(".line")
        .data(points)
        .enter()
        .append("path")
          .attr("fill", 'none')
          .attr("stroke-width", 2.5)
          .attr("stroke", function(d,i) {
            console.log(d.color)
            return d.color;
          })
          .attr("d", function(d){
            return d3.line()
              .x(function(d) {
                return xS(d[0]);
              })
              .y(function(d) { return yS(d[1]); })
              (d.serie)
          })
        
        {% comment %} timeSeriesSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight  + ")")
          .call(d3.axisBottom(xS));
        
        timeSeriesSvg.append("g")
          .attr("transform", "translate(30, 0)")
          .call(d3.axisLeft(yS)); {% endcomment %}

        
    }


    function selectPollutant(pollutant_id){
      base_url = "/main/pollutant_projection/{{dataset.id}}/"
      pol_name = ''
      for(var i =0; i< all_pollutants.length; i++ ){
        if(all_pollutants[i]['id'] == pollutant_id){
          pol_name = all_pollutants[i]['name']
        }
      }
      document.getElementById("selectedPollutantTitle").innerHTML = 'Projection for: ' + pol_name;
      d3.json(base_url + pollutant_id, function(error, data){
        console.log(data)
        var data = JSON.parse(data);
        var coordenates = data['coordenates']
        var series = data['series']

        for (var i = 0; i < coordenates.length; i++){
          points[i]['p_pos'] = coordenates[i]

          for (var j = 0; j < 365; j++) {
            points[i]['serie'][j][1] = series[i][j];
          }

          console.log(points[i]['serie']);
        }
        updatePollutantCircles();
        updateSeries();
      })
    }

    function selectStation(station_id){
      resetSelection()
      for( var i = 0; i < points.length; i++){
        if(points[i]['station_id'] == station_id){
          //points[i]['color'] = 'rgba(0, 0, 250, 1)'
          //points[i]['color'] = '#' + Math.floor(Math.random()*16777215).toString(16)
          points[i]['color'] = station_colors[station_id]
          points[i]['r'] = radiusSelected
        }else{
          points[i]['color'] = 'rgba(0, 0, 0, 0.1)'
          points[i]['r'] = radiusUnselected
        }
      }
      updateMainCircles()
      updatePollutantCircles()
      updateSeries()
    }

    function selectYear(year){
      resetSelection()
      for( var i = 0; i < points.length; i++){
        if(points[i]['year'] == year){
          points[i]['color'] = years_colors[year]
          points[i]['r'] = radiusSelected
        }else{
          points[i]['color'] = 'rgba(0, 0, 0, 0.1)'
          points[i]['r'] = radiusUnselected
        }
      }
      updateMainCircles()
      updatePollutantCircles()
      updateSeries()
    }

    function resetSelection(){
      for( var i = 0; i < points.length; i++){
        points[i]['color'] = 'rgba(0, 0, 0, 1)'
      }
    }

    function showRatio(value){
      ratio = value;
      var alphas = []
      for  (var i = 0; i < all_pollutants.length; i++) {
        alphas.push(all_pollutants[i]['val'])
      }

      base_url = "/main/projection/{{dataset.id}}/"

      console.log(ratio)


      d3.json(base_url + alphas + '/' + ratio, function(error, data){
        var coordenates = JSON.parse(data);
        for (var i = 0; i < coordenates.length; i++){
          points[i]['m_pos'] = coordenates[i]
        }
        updateMainCircles();
      })
    }

    function showVal(value, pollutant_id){

      var alphas = []
      for  (var i = 0; i < all_pollutants.length; i++) {
        if (all_pollutants[i]['id'] == pollutant_id) {
          all_pollutants[i]['val'] = value
        }
        alphas.push(all_pollutants[i]['val'])
      }

      base_url = "/main/projection/{{dataset.id}}/"



      d3.json(base_url + alphas + '/' + ratio, function(error, data){
        var coordenates = JSON.parse(data);
        for (var i = 0; i < coordenates.length; i++){
          points[i]['m_pos'] = coordenates[i]
        }
        updateMainCircles();
      })
    }

    function myFunction() {
      document.getElementById("myDropdown").classList.toggle("show");
    }
    
    // Close the dropdown menu if the user clicks outside of it
    window.onclick = function(event) {
      if (!event.target.matches('.dropbtn')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        var i;
        for (i = 0; i < dropdowns.length; i++) {
          var openDropdown = dropdowns[i];
          if (openDropdown.classList.contains('show')) {
            openDropdown.classList.remove('show');
          }
        }
      }
    } 
    
  </script>
  
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="{% static 'd3-lasso/build/d3-lasso.min.js' %}"></script>
  <script>
      // Sizes stuff
      var margin = {top: 10, right: 0, bottom: 40, left: 40}
      var mainWidth = 400 - margin.left - margin.right
      var mainHeight = 400 - margin.top - margin.bottom
      var radiusSelected = 6;
      var radiusUnselected = 4;

      var spanel = 300


      var spanelWidth = spanel - margin.left - margin.right;
      var spanelHeight = spanel - margin.top - margin.bottom;

      {% comment %} var selectedColor = '#2c44a3' {% endcomment %}
      {% comment %} var unselectedColor = '#000000' {% endcomment %}
      var selectedColor = 'rgba( 17, 5, 120, 0.7 )'
      var unselectedColor = 'rgba( 0, 0, 0, 0.1 )'
      var mainProjectionSvg = 0;
      var pollutantProjectionSvg = 0;
      var timeSeriesSvg = 0;

      var xS = d3.scaleLinear()
        .domain([0, 365])
        .range([ 0, spanelWidth ]);
      var yS = d3.scaleLinear()
        .domain([800, 0])
        .range([0, spanelHeight]);

      

      d3.json("{% url 'windows' dataset.id %}", function (error, data) {

        // Parse json
        var jsonData = JSON.parse(data);
        data = JSON.parse(data);

        points = []
        for (var i = 0; i < data.length; i++) {
          point_data = {}
          point_data['m_pos'] = [data[i].fields["g_x"], data[i].fields["g_y"]]
          point_data['p_pos'] = [data[i].fields["x"], data[i].fields["y"]]
          point_data['station_id'] = data[i].fields['station']
          point_data['color'] = 'rgba( 0, 0, 0, 1 )'
          point_data['r'] = radiusUnselected
          point_data['serie'] = Array.from({length: 365}, (_, i) => [0,1])
          point_data['year'] = parseInt(data[i].fields['begin_date'].substring(0, 4))
          
          
          var ite = Array.from({length: 365}, (_, i) => i + 1)
          var values = JSON.parse(data[i].fields.values)
          values = values.map(Number);
          for (var j = 0; j < 365; j++) {
            point_data['serie'][j][1] = values[j];
            point_data['serie'][j][0] = ite[j];
          }
          points.push(point_data);
        }


        // Prepare the data
        for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var values = JSON.parse(obj.fields.values)
          obj.values = values.map(Number);

          var xscale = d3.scaleLinear()
                .range([0,mainWidth])
                .domain([0,365]);
          
          obj['x_axis'] = d3.axisBottom().scale(xscale)
          obj['x_val']  = Array.from({length: 365}, (_, i) => i + 1)
          obj['path'] = Array.from({length: 365}, (_, i) => [0,1])

          for (var j = 0; j < 365; j++) {
            obj.path[j][1] = obj.values[j];
            obj.path[j][0] = obj.x_val[j];
          }
          data[i] = obj
        }

        // Setting main projection
        var mainProjectionArea = d3
          .select("#mainProj")
          .append("svg")
          .attr("width", mainWidth + margin.left + margin.right)
          .attr("height", mainHeight + margin.top + margin.bottom);

        mainProjectionSvg = mainProjectionArea
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        
        var x = d3.scaleLinear()
          .domain([-1, 1])
          .range([ 0, mainWidth ]);
        
        mainProjectionSvg.append("g")
          .attr("transform", "translate(0," + mainHeight + ")")
          .call(d3.axisBottom(x));
        
        var y = d3.scaleLinear()
          .domain([-1, 1])
          .range([ mainHeight, 0]);

        mainProjectionSvg.append("g")
          .call(d3.axisLeft(y));
        

        var circles = mainProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(points)
          .enter()
          .append("circle")
          .attr("cx", (d) => x(d.m_pos[0]))
          .attr("cy", (d) => y(d.m_pos[1]))
          .attr("r", radiusUnselected);
        
        

        
        
        // Setting pollutant projection
        var pollutantProjectionArea = d3
          .select("#pollutantProj")
          .append("svg")
          .attr("width", spanelWidth + margin.left + margin.right)
          .attr("height", spanelHeight + margin.top + margin.bottom);

        pollutantProjectionSvg = pollutantProjectionArea
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        
        var x = d3.scaleLinear()
          .domain([-1, 1])
          .range([ 0, spanelWidth ]);
        
        pollutantProjectionSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight + ")")
          .call(d3.axisBottom(x));
        
        var y = d3.scaleLinear()
          .domain([-1, 1])
          .range([ spanelHeight, 0]);
        pollutantProjectionSvg.append("g")
          .call(d3.axisLeft(y));

        var pollutantCircles = pollutantProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(points)
          .enter()
          .append("circle")
          .attr("cx", (d) => x(d.p_pos[0]))
          .attr("cy", (d) => y(d.p_pos[1]))
          .attr("r", radiusUnselected);


        var middle = spanel / 2;

        pollutantProjectionArea
            .append('g')
            .attr('transform', 'translate(' + 10 + ', ' + middle + ')')
            .append('text')
            .attr('text-anchor', 'middle')
            .attr('transform', 'rotate(-90)')
            .text('Magnitude');

        pollutantProjectionArea
            .append('g')
            .attr('transform', 'translate(' + middle + ', ' + (spanel - 10) + ')')
            .append('text')
            .attr('text-anchor', 'middle')
            .text('Shape');

  


        // Lasso functions
        var lasso_main_start = function () {
          lassoMain
            .items()
            .attr("r", radiusUnselected)
            .classed("not_possible", true)
            .classed("selected", false);
          
        };
        var lasso_main_draw = function () {
          lassoMain
            .possibleItems()
            .classed("not_possible", false)
            .classed("possible", true);
          lassoMain
            .notPossibleItems()
            .classed("not_possible", true)
            .classed("possible", false);
        };

        // Lasso functions
        var lasso_pollutant_start = function () {
          lassoPollutant
            .items()
            .attr("r", radiusUnselected)
            .classed("not_possible", true)
            .classed("selected", false);
        };
        var lasso_pollutant_draw = function () {
          lassoPollutant
            .possibleItems()
            .classed("not_possible", false)
            .classed("possible", true);
          lassoPollutant
            .notPossibleItems()
            .classed("not_possible", true)
            .classed("possible", false);
        };

      

      timeSeriesSvg = d3.select("#timeSeries")
        .append("svg")
          .attr("width", spanelWidth + margin.left + margin.right)
          .attr("height", spanelHeight + margin.top + margin.bottom)
        .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        
        
        
        timeSeriesSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight + ")")
          .call(d3.axisBottom(xS));
        timeSeriesSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight + ")");

        // Add Y axis
        

        timeSeriesSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight + ")")
          .call(d3.axisBottom(xS));
        timeSeriesSvg.append("g")
          .attr("transform", "translate(0," + spanelHeight + ")")
          .call(d3.axisBottom(xS).ticks(5));
        timeSeriesSvg.append("g")
          .call(d3.axisLeft(yS));

        updateSeries()

        function updateData(selectedData, unselectedData) {

          // Update main view
          var xMain = d3.scaleLinear()
            .domain([-1, 1])
            .range([ 0, mainWidth ]);
          
          var yMain = d3.scaleLinear()
            .domain([-1, 1])
            .range([ mainHeight, 0]);

          circlesMain = mainProjectionSvg.selectAll("circle");
          circlesMain.remove();

          var circlesMain = mainProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(selectedData)
          .enter()
          .append("circle")
          .style('fill', function(d,i) {
              return selectedColor;
          })
          .attr("cx", (d) => xMain(d.m_pos[0]))
          .attr("cy", (d) => yMain(d.m_pos[1]))
          .attr("r", radiusSelected);
        
          var circlesMain = mainProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(unselectedData)
          .enter()
          .append("circle")
          .style('fill', function(d,i) {
              return unselectedColor;
          })
          .attr("cx", (d) => xMain(d.m_pos[0]))
          .attr("cy", (d) => yMain(d.m_pos[1]))
          .attr("r", radiusUnselected);
          
          circlesMain = mainProjectionSvg.selectAll("circle");

          lassoMain.items(circlesMain)


          // Update pollutant projection view
          var xPoll = d3.scaleLinear()
            .domain([-1, 1])
            .range([ 0, spanelWidth ]);
          
          var yPoll = d3.scaleLinear()
            .domain([-1, 1])
            .range([ spanelHeight, 0]);

          circlesPoll = pollutantProjectionSvg.selectAll("circle");
          circlesPoll.remove();

          var circlesPoll = pollutantProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(selectedData)
          .enter()
          .append("circle")
          .style('fill', function(d,i) {
              return selectedColor;
          })
          .attr("cx", (d) => xPoll(d.p_pos[0]))
          .attr("cy", (d) => yPoll(d.p_pos[1]))
          .attr("r", radiusSelected);
        
          var circlesPoll = pollutantProjectionSvg
          .append("g")
          .selectAll(".dot")
          .data(unselectedData)
          .enter()
          .append("circle")
          .style('fill', function(d,i) {
              return unselectedColor;
          })
          .attr("cx", (d) => xPoll(d.p_pos[0]))
          .attr("cy", (d) => yPoll(d.p_pos[1]))
          .attr("r", radiusUnselected);
          
          circlesPoll = pollutantProjectionSvg.selectAll("circle");

          lassoPollutant.items(circlesPoll);




          // Update time series
          path = timeSeriesSvg.selectAll("path");
          path.remove();


          console.log(spanelHeight);
          console.log(y(30));
          console.log(y(100));
          console.log(y(200));
          
          timeSeriesSvg.selectAll(".line")
            .data(selectedData)
            .enter()
            .append("path")
              .attr("fill", "none")
              .attr("stroke", selectedColor)
              .attr("stroke-width", 2.5)
              .attr("d", function(d){
                return d3.line()
                  .x(function(d) {
                    return xS(d[0]);
                  })
                  .y(function(d) { return yS(d[1]); })
                  (d.serie)
              })
            
          timeSeriesSvg.selectAll(".line")
            .data(unselectedData)
            .enter()
            .append("path")
              .attr("fill", "none")
              .attr("stroke", unselectedColor)
              .attr("stroke-width", 2)
              .attr("d", function(d){
                return d3.line()
                  .x(function(d) {
                    return xS(d[0]);
                  })
                  .y(function(d) { return yS(d[1]); })
                  (d.serie)
              })

        
          
          
        }


        

        var lasso_main_end = function () {
          // Reset the color of all dots
          lassoMain.items().classed("not_possible", false).classed("possible", false);

          // Style the selected dots
          lassoMain.selectedItems().classed("selected", true).attr("r", radiusSelected);

          // Reset the style of the not selected dots
          lassoMain.notSelectedItems().attr("r", radiusUnselected);

          var selectedArray = [];
          var notSelectedArray = [];

          var selected = lassoMain.selectedItems().filter(function (d) {
            selectedArray.push(d);
            return d.selected === true;
          });

          var notSelected = lassoMain.notSelectedItems().filter(function (d) {
            notSelectedArray.push(d);
            return d.selected === true;
          });

          selectedData = lassoMain.selectedItems().classed("selected", true);

          {% comment %} var circles = svg
          .selectAll("circle")
          .attr("fill", '#948082' )
          .attr("r", 6); {% endcomment %}

          {% comment %} selectedData
            .attr("fill", '#948082' )
            .attr("r", 6)
          
          lassoMain.notSelectedItems()
            .attr("r", 3.5)
            .attr("fill", '#000000'); {% endcomment %}


          updateData(selectedArray, notSelectedArray);
        };

        var lasso_pollutant_end = function () {
          // Reset the color of all dots
          lassoPollutant.items().classed("not_possible", false).classed("possible", false);

          // Style the selected dots
          lassoPollutant.selectedItems().classed("selected", true).attr("r", radiusSelected);

          // Reset the style of the not selected dots
          lassoPollutant.notSelectedItems().attr("r", radiusUnselected);

          var selectedArray = [];
          var notSelectedArray = [];

          var selected = lassoPollutant.selectedItems().filter(function (d) {
            selectedArray.push(d);
            return d.selected === true;
          });

          var notSelected = lassoPollutant.notSelectedItems().filter(function (d) {
            notSelectedArray.push(d);
            return d.selected === true;
          });

          selectedData = lassoPollutant.selectedItems().classed("selected", true);
          updateData(selectedArray, notSelectedArray);
        };

        lassoMain = d3
          .lasso()
          .closePathSelect(true)
          .closePathDistance(200)
          .items(circles)
          .targetArea(mainProjectionArea)
          .on("start", lasso_main_start)
          .on("draw", lasso_main_draw)
          .on("end", lasso_main_end);
        mainProjectionArea.call(lassoMain);

        lassoPollutant = d3
          .lasso()
          .closePathSelect(true)
          .closePathDistance(200)
          .items(pollutantCircles)
          .targetArea(pollutantProjectionArea)
          .on("start", lasso_pollutant_start)
          .on("draw", lasso_pollutant_draw)
          .on("end", lasso_pollutant_end);
        pollutantProjectionArea.call(lassoPollutant);
        



      });

      // console.log(data);
  </script>
  {% endif %}
</div>

{% endblock %}
